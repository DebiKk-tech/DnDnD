Пояснительная записка

Итак, как же работает DnDnD?
1. Главное окно
Есть главное окно. В нижней его части есть три группы кнопок: две большие, три средние и четыре маленькие. В зависимости
от того, сколько вариантов выбора есть у игрока, активизируется та или иная группа кнопок, к каждой кнопке прикрепляется
функция. В верхней части есть QProgressBar, который не виден в обычное время, но появляется во время боя. Когда он
появляется, над ним появляется картинка и название монстра, с которым сражается игрок. Для удобства есть файл input_functions.py.
В нём прописаны функции, которые позволяют переключить видимость групп кнопок, изменить текст на них и привязать функции
Вывод текста осуществляется с помощью функции output - она берет старый текст из QPlainTextEdit и посимвольно добавляет
выводимый текст. После каждого символа она ждет долю секунды, чтобы вывод был красивый, понятный и опрятный
В каждой локации есть кнопка "Уйти", к которой привязана функция start_location.
2. get-функции
Так как код раздроблен на файлы, возникает необходимость импортировать код. Однако тогда возикают ошибки из-за перекрестного
импорта: файл В импортирует файл А, который импортирует файл В, который импортирует файл А и так далее. Чтобы это обойти,
я создал get-функции: они передают одну-три переменные в другие файлы
3. Регистрация
Я сделал так, что в начале, при инициализации главного окна, оно становится невидимым и появляется окно регистрации. Там
пользователь вводит логин, пароль и выбирает, хочет он войти в существующий аккаунт или создать новый. В зависимости от
этого с помощью функций из файла sqlite_functions создаётся новый профиль или загружается старый в переменную pl класса
Player. При успешной регистрации/входе при нажатии на кнопку окно регистрации закрывается и основное окно становится
видимым. Однако, если пользователь закроет окно с помощью системной кнопки "Х", возникнет ошибка: пользователь не будет
прикреплён к аккаунту. Поэтому показ основного окна привязан к кнопке "Войти", а не к закрытию окна
4. Структура кода
В самом начале (после регистрации) срабатывает функция start_location (она ещё много раз повстречается), она предлагает игроку выбор: пойти
в магазин, в таверну или в Подземелье, сражаться с монстрами. Каждая локация реализована через функцию. Вообще любое
нажатие кнопки прикреплено к функции. Из-за этой трудности (каждую кнопку надо привязать к функции) в коде, к сожалению,
есть костыльные решения, так и помеченные: 'костыль'.
5. Магазин
Появляются четыре кнопки (костыль: пришлось создать доп.функции). Игрок выбирает, что ему купить
В магазине с помощью QInputDialog выбирается предмет, который игрок хочет купить - оружие, броня или амулет. Есть вариант
"ничего", и пользователь обязан что-то выбрать. Процесс покупки довольно схож, отличаются лишь надписи в QInputDialog и
словари с предметами, поэтому была создана функция buy
6. Таверна
В таверне все немного сложнее. Есть кнопка, которая открывает вторую форму - форму для броска костей. Если число, введённое
игроком, совпадает с числом, выпавшим на костях, игрок получает 100 монет, если нет - проигрывает 20. На время работы второго
окна главное также прячется, и, при закрытии формы, появляется. Также игрок может купить зелья или эликсиры, их количество
вводится с помощью QInputDialog. Кроме того, игрок может передать монеты другим игрокам, обращаясь по логину
7. Классы Player, Weapon, Armor и Amulet
Для игрока есть класс Player, в нем хранится вся информация об игроке, а также есть несколько полезных функций, которые
нужны, чтобы сократить код. Классы Weapon, Armor и Amulet созданы для тех же функций, сокращающих код и понятных атрибутов
(self.weapon.damage понятнее, чем self.weapon[0])
9. Подземелье
Подземелье - основная локация. Здесь игрок сражается с монстрами, получает монеты и опыт. Состоит из подлокаций, к которым
игрок переходит с помощью очередных костыльных функций. Для каждой локации есть функция [имя локации]_happening_choice.
Это промежуточная функция, которая решает, когда сработать основной функции happening_choice (которая выбирает, что произойдет
и/или какой монстр нападёт на игрока и выполняет происшествие), в противном случае всё работает нормально, прежде чем
появляется монстр - тогда он просто пропускается программой.
10. Таблица лидеров
Есть таблица лидеров - это кнопка, которая открывает окно с таблицей, где есть список всех игроков на устройстве и сортирует
список в зависимости от их очков. Оно никак не влияет на основное окно, поэтому ничего не отключается
11. Класс Monster и сражения
Есть класс Monster. Он отличается от остальных классов тем, что есть функции, которые влияют на код непосредственно
Сражение происходит так: создаётся новый экземпляр класса Monster (с характеристиками в зависимости от того, какой монстр
был выбран рандомом) и начинается бой. Вставляется картинка, показывается прогресс бар. Игроку предоставляются варианты действий:
атака, лечение или защита. После любого успешного действия игрока (лечение может быть неуспешным, если у игрока нет зелий
для лечения) ходит монстр, который наносит урон игроку. Когда монстр побеждён, игроку начисляется награда и программа работает
дальше (там костыльное решение с промежуточными функциями)
12. Смерть
Если игрок умер в бою, то в его профиле пункт dead изменяется, вылезает QMessageBox, информирующий о смерти и окно закрывается.
Если пользователь пытается войти в профиль, на котором он умер, возникает ошибка
13. Обновление профиля
Профиль игрока обновляется, когда программа закрывается. В базу данных заносятся все изменения